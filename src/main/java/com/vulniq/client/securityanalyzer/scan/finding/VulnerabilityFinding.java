
/*
 *     VulnIQ Security Scanner, Terzi
 *     Copyright (C) 2021  SBOSoft A.S. and its affiliates
 *     Contact : info@vulniq.com www.vulniq.com
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.vulniq.client.securityanalyzer.scan.finding;

import com.vulniq.client.securityanalyzer.datacollection.windows.WindowsHotFix;
import com.vulniq.client.securityanalyzer.logging.TerziLog;
import com.vulniq.client.securityanalyzer.oval.OVALInterpreter;
import com.vulniq.client.securityanalyzer.vulniqapi.VulnIQVulnerabilityVerificationData;
import com.vulniq.client.securityanalyzer.vulniqapi.VulnIQVulnerabilityData;
import org.mitre.oval.xmlschema.oval_results_5.ResultEnumeration;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class VulnerabilityFinding extends ScanFinding
{
    private int viqDataType;
    /**
     * data guid for the vulnerability definition from VulnIQ
     */
    private String viqDataGuid;
    private boolean exploitExists;
    private boolean fixExists;
    private List<VulnIQVulnerabilityVerificationData> verificationData = new LinkedList<>();
    /**
     * ovalDataGuid => ResultEnumeration
     */
    private Map<String, ResultEnumeration> ovalResults = new HashMap<>();

    /**
     * ovalDataGuid => logs
     */
    private Map<String, List<OVALInterpreter.OVALLogEntry>> ovalLogs = new HashMap<>();

    private Map<String, List<WindowsHotFix>> windowsHotfixResults = new HashMap<>();

    public VulnerabilityFinding(VulnIQVulnerabilityData viqVuln)
    {
        this.setFindingType(FindingType.Vuln);
        this.verificationStatus = VerificationStatus.Unverified;
        this.viqDataType = viqVuln.getDataType();
        this.viqDataGuid = viqVuln.getGuid();
        this.name = viqVuln.getName();
        this.description = viqVuln.getDescription();
        this.score = ScanFinding.getFindingScoreFromVulnIQDataScore(viqVuln.getDataScore());
        this.exploitExists = viqVuln.isExploitExists();
        this.fixExists = viqVuln.isFixExists();
        //TODO use other fields?
    }

    public void addMSKBArticleResult(VulnIQVulnerabilityVerificationData viqVerificationData, WindowsHotFix hotfix)
    {
        this.verificationData.add(viqVerificationData);
        if(!this.windowsHotfixResults.containsKey(viqVerificationData.getGuid()))
        {
            this.windowsHotfixResults.put(viqVerificationData.getGuid(), new LinkedList<>());
        }
        this.windowsHotfixResults.get(viqVerificationData.getGuid()).add(hotfix);
        if(hotfix==null)
        {
            //hotfix is not installed, so the vulnerability exists
            this.setVerificationStatus(VerificationStatus.Verified_MSHotfix);
            this.setVerificationDescription("VULNERABLE: Hotfix " + viqVerificationData.getGuid() + " which fixes this issue is not installed");
        }
        else
        {
            setVerificationStatus(VerificationStatus.Verified_MSHotfix);
            setVerificationDescription("NOT VULNERABLE: Hotfix " + viqVerificationData.getGuid() + " which fixes this issue is installed.");
            setScore(FindingScore.Informational);
        }
    }

    public void addOVALResult(VulnIQVulnerabilityVerificationData viqVerificationData, String ovalDataGuid, ResultEnumeration result, List<OVALInterpreter.OVALLogEntry> logs)
    {
        this.verificationData.add(viqVerificationData);
        this.ovalLogs.put(ovalDataGuid, logs);
        this.ovalResults.put(ovalDataGuid, result);
        switch (result)
        {
            case TRUE:
                setVerificationStatus(ScanFinding.VerificationStatus.Verified_OVAL);
                setVerificationDescription("VULNERABLE: Verified by evaluating OVAL definition " + ovalDataGuid + ".");
                setNeedsReview(false);
                break;
            case FALSE:
                setVerificationStatus(ScanFinding.VerificationStatus.Verified_OVAL);
                setVerificationDescription("NOT VULNERABLE: Verified by evaluating OVAL definition " + ovalDataGuid + ".");
                setScore(FindingScore.Informational);
                setNeedsReview(false);
                break;
            case ERROR:
                setNeedsReview(true);
                setVerificationDescription("ERROR: OVAL definition," + ovalDataGuid +", was run for verification but OVAL evaluation resulted in an error.");
                break;
            case UNKNOWN:
                setNeedsReview(true);
                setVerificationDescription("ERROR: Failed to load OVAL definition "+ovalDataGuid+" for verification.");
                break;
            //TODO handle other cases
            default:
                //This should never happen but just in case
                setNeedsReview(true);
                setVerificationDescription("ERROR: Unexpected OVAL result:" + result);
                TerziLog.supportCase("Vulnerability.addOVALResult", "Unexpected OVAL ResultEnumeration",
                        "ResultEnumeration value '"+result+"' is not supported/expected",
                        "Please report this issue to VulnIQ support",
                        null);
                break;
        }

    }


    public String getViqDataGuid()
    {
        return viqDataGuid;
    }

    public void setViqDataGuid(String viqDataGuid)
    {
        this.viqDataGuid = viqDataGuid;
    }

    public Map<String, ResultEnumeration> getOvalResults()
    {
        return ovalResults;
    }

    public void setOvalResults(Map<String, ResultEnumeration> ovalResults)
    {
        this.ovalResults = ovalResults;
    }

    public Map<String, List<OVALInterpreter.OVALLogEntry>> getOvalLogs()
    {
        return ovalLogs;
    }

    public void setOvalLogs(Map<String, List<OVALInterpreter.OVALLogEntry>> ovalLogs)
    {
        this.ovalLogs = ovalLogs;
    }

    public boolean isExploitExists()
    {
        return exploitExists;
    }

    public void setExploitExists(boolean exploitExists)
    {
        this.exploitExists = exploitExists;
    }

    public boolean isFixExists()
    {
        return fixExists;
    }

    public void setFixExists(boolean fixExists)
    {
        this.fixExists = fixExists;
    }


    public Map<String, List<WindowsHotFix>> getWindowsHotfixResults()
    {
        return windowsHotfixResults;
    }

    public void setWindowsHotfixResults(Map<String, List<WindowsHotFix>> windowsHotfixResults)
    {
        this.windowsHotfixResults = windowsHotfixResults;
    }

    public int getViqDataType()
    {
        return viqDataType;
    }

    public void setViqDataType(int viqDataType)
    {
        this.viqDataType = viqDataType;
    }
}
